Основные шаги алгоритма:

1. Выбор опорного элемента (pivot):
   В каждом вызове алгоритма выбирается элемент массива, который будет использоваться в качестве опорного (pivot). Этот элемент разделяет массив на две части. Опорный элемент может быть выбран разными способами: первым элементом, последним элементом, случайным элементом или медианой из нескольких элементов.

2. Разделение (partition):
   Все элементы, меньшие опорного, перемещаются в левую часть массива, а все элементы, большие опорного, перемещаются в правую часть. В итоге опорный элемент оказывается на своём правильном месте в отсортированном массиве, и вокруг него формируются две подгруппы элементов.

3. Рекурсивная сортировка подмассивов:
   Затем быстрая сортировка рекурсивно применяется к левому и правому подмассивам (то есть к частям массива, находящимся слева и справа от опорного элемента).

4. Базовый случай:
   Рекурсия завершается, когда подмассивы содержат один или ноль элементов, так как такие массивы уже отсортированы.


Временная сложность:

- Средний случай: O(n log n), где n — количество элементов в массиве. Средняя производительность достигается за счет того, что массив рекурсивно делится на примерно равные части.
- Худший случай: O(n²). Это происходит, если на каждом этапе разбиения массив делится неравномерно, например, когда массив уже отсортирован и в качестве опорного элемента всегда выбирается минимальный или максимальный элемент.
- Лучший случай: O(n log n). Это происходит, когда массив на каждом шаге делится на две равные части.

Пространственная сложность:

1. Основное использование памяти:
   - QuickSort обычно работает in-place, что означает, что он не требует дополнительной памяти для хранения данных. Массив сортируется непосредственно в памяти, где он был изначально расположен. Это означает, что для данных (массив) требуется O(1) дополнительной памяти, помимо самого массива.

2. Использование памяти на стеке вызовов (рекурсия):
   - Основной вклад в пространственную сложность даёт глубина рекурсивных вызовов. В худшем случае (например, если массив всегда делится на части размером 1 и n-1), глубина рекурсии может достигать O(n), что приведёт к пространственной сложности O(n).
   - В среднем и лучшем случае глубина рекурсии будет O(log n), что соответствует пространственной сложности O(log n).

Итог:
- Средний и лучший случай: O(log n) — если массив делится равномерно, то рекурсивная глубина будет логарифмической.
- Худший случай: O(n) — если массив делится крайне неравномерно (например, массив уже отсортирован или все элементы одинаковы), то рекурсивная глубина может быть линейной.

Преимущества и недостатки:

- Преимущества:
  - Очень эффективный алгоритм с низкой затратой на память (в зависимости от реализации).
  - Хорошо работает на большинстве данных.
  - Поддерживает быструю сортировку на месте (in-place).

- Недостатки:
  - В худшем случае может оказаться менее эффективным, чем другие алгоритмы (например, HeapSort или MergeSort).
  - Быстрая сортировка не стабильна, что означает, что равные элементы могут менять порядок.
