# Хэш-функции

Требования к хэш-функции:

1. Одинаковые данные выдают одинаковый хэш
2. Необратимое преобразование из хэша во входные данные
3. Хэш всегда фиксированного размера
4. Разные данные выдают разный хеш (что невозможно, так как на вход можно подать бесконеченое кол-во данных, а кол-во бит для хэша фиксированно, из-за чего возникают коллизии и задача хэш функции быть устойчивой к коллизиям и не дать возможность злоумышленникам найти эту коллизию (получение одного и того же хэша из разных входных данных))

Хеширование - это преобразование данных любой длины в данные заданной длины.

3 семейства хэш-функций:

1. MD (MD-2, MD-4, MD-5 (128 бит))
2. CRC (CRC-1, CRC-4, ..., CRC-64 (64 бита))
3. SHA (SHA-1 (128 бит), SHA-2 (224-512 бит), SHA-3 (224-512 бит))

Отличаются между собой криптостойкостью, разрядностью выходного хэша и скоростью вычисления. Чем больше разрядность тем более криптостойкий алгоритм и тем дольше он будет выполняться.

Не смотря на то, что CRC не является криптостойкой, она используется для вычисления контрольной суммы (для проверки целостности информации при передачи данных, также, например, CRC используется в png).

Если хэшом является 32 битное значение и сам ключ является типом int, то сам ключ может являться хэшем, потому что каждое число уже уникально поэтому приводить его в другой вид нам не требуется.

Если хэшом является строка, то ключём является массив символов типа char, самый простой способ для вычисления хэша это склеивание всех символов (in_str << 8) + in.str[i]). Проблема с которой можно столкнутся заключается в том, что если входная строка больше 4 символов то хэш будет определяться только 4 последними символами. Кроме этого полученный хэш может не является индексом массива (выходить за пределы), для получения индекса разделим хэш по модулю на длину массива. При делении по модулю есть одна важная особенность, если делитель можно представить как 2^k, то остатком от деления всегда будут являться последние k бит хэша. Например, если размер массива 256 то при делении по модулю остатком будут 8 бит (2^8 = 256) поэтому индекс в массиве всегда будет определяться последним символом (то есть индекс для двух входных значений (jane и name, например) будет одним и тем же несмотря на то, что хэш у них был разный). При таком подходе коллизии будут встречаться часто.

----------------------------- ВСЕ ЧТО ДАЛЬШЕ ДО СЛЕДУЮЩЕЙ ГЛАВЫ МНЕ НЕ ПОНЯТНО И СКОРЕЕ ВСЕГО НЕ ПРАВИЛЬНО

Возьмём размер массива в виде простого числа, тогда при делении входных значений с одинаковыми последними 8 битами будут давать разные индексы, но склеивание символов путём их сдвига на 8 бит это тоже самое, что и умножение на 256 (2^k = 256) и если при этом размер массива на который мы делим можно представить как 2^k-1, то все перестановки одной и той же строки ключа (dog, dgo, odg ... * 256 всегда будут выдавать одинаковый индекс), проблема в том, что некоторые простые числа могут быть представлены как 2^k-1 (31), поэтому нам нужны не просто простые числа, а простые числа которые не будут подходить под это условие.

d - 01100100
o - 01101111
g - 01100111

2^8 = 256 и 2^5-1 = 31
dog - 00000000 01100100 01101111 01100111 / 32 (100000) - 1 = 

dgo - 00000000 01100100 01100111 01101111 / 32 (100000) - 1 = 

# Хэш-таблицы 011001000110111101100111

#include <stdio.h>

int get_index(const char *s, int len)
{
	int i;
	unsigned int hash = 0;

	for (i = 0; i < len; i++) {
		hash = (hash << 8) + s[i];
	}
	return hash % 31;
}

int main()
{
	int r1, r2, r3, r4, r5;

	r1 = get_index("dog", 3);
	r2 = get_index("god", 3);
	r3 = get_index("dgo", 3);
	r4 = get_index("odg", 3);
	r5 = get_index("ogd", 3);

	printf("dog: %d\n", r1);
	printf("god: %d\n", r2);
	printf("dgo: %d\n", r3);
	printf("odg: %d\n", r4);
	printf("ogd: %d\n", r5);

	return 0;
}

-----------------------------

Способы борьбы с коллизиями:

1. Связные списки (по индексу массива хранится не одно значение, а односвязный список который хранит ключ и и значение). Связные списки плохо поддаются кешированию процессором, так как списки раскиданы по всей памяти.
2. Таблицы с открытой адресацией (ячейка хранит только один объект с ключом и значением. Суть этого метода заключается в том, что получая коллизию, мы продолжаем поиск в нашем массиве пока не найдём свободную ячейку в которую и будет помещён объект, шаг с которым мы ищем свободную ячейку зависит от алгоритма.

Ключом в хеш-таблице может быть любой тип (число, строка, массив, объект и т.д).

Заполнять хеш-таблицу можно заполнять не более чем на 70%-75%, иначе кол-во коллизий существенно увеличится. Для этого потребуется выделить новую память и заново заполнить хэш-таблицу (просто скопировать неудачная идея, так как после изменения размера хэш-таблицы выдаваемый индекс может быть другим).
